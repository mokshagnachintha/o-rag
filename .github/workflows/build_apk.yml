name: Build Android APK

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:   # lets you trigger manually from GitHub website

jobs:
  build-apk:
    runs-on: ubuntu-22.04
    timeout-minutes: 120

    steps:
      # ── 1. Checkout code ──────────────────────────────────── #
      - name: Checkout repository
        uses: actions/checkout@v4

      # ── 2. Set up Python ─────────────────────────────────── #
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # ── 3. Set up Java 17 (required by p4a's AGP 8.x) ────────────── #
      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      # ── 4. Install system dependencies ───────────────────── #
      - name: Install system packages
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            git zip unzip \
            autoconf libtool pkg-config \
            zlib1g-dev libncurses5-dev libncursesw5-dev \
            libtinfo5 cmake libffi-dev libssl-dev \
            wget lld clang

      # ── 5. Install Buildozer + python-for-android ────────── #
      - name: Install Buildozer
        run: |
          pip install --upgrade pip setuptools wheel cython
          pip install buildozer python-for-android

      # ── 6. Cache Android SDK/NDK and p4a builds ──────────── #
      - name: Cache Buildozer global dir
        uses: actions/cache@v4
        with:
          path: ~/.buildozer
          key: buildozer-${{ runner.os }}-${{ hashFiles('buildozer.spec') }}
          restore-keys: buildozer-${{ runner.os }}-

      - name: Cache .buildozer project dir
        uses: actions/cache@v4
        with:
          path: .buildozer
          key: buildozer-project-${{ runner.os }}-${{ hashFiles('buildozer.spec','requirements.txt') }}
          restore-keys: buildozer-project-${{ runner.os }}-

      # ── 6. Clone llama.cpp source (compiled after NDK is ready) ─────── #
      - name: Clone llama.cpp source
        run: |
          git clone --depth 1 https://github.com/ggml-org/llama.cpp.git llama_cpp_src
          echo "llama.cpp cloned: $(ls llama_cpp_src)"

      # ── 8. Build APK ─────────────────────────────────────────────── #
      - name: Build Android debug APK
        env:
          # Give the Gradle daemon enough heap for asset processing
          GRADLE_OPTS: "-Xmx4g -XX:MaxMetaspaceSize=512m"
        run: |
          # Confirm Java version
          java -version
          # Delete stale Gradle dist - regenerates fresh under current JDK
          rm -rf .buildozer/android/platform/build-arm64-v8a/dists/
          # Pin Cython to a version compatible with pyjnius (kivy dep)
          pip install "cython==0.29.37" --quiet
          # Accept Android SDK licenses explicitly (avoids yes-pipe exit code issue)
          mkdir -p ~/.android && touch ~/.android/repositories.cfg
          yes 2>/dev/null | $HOME/.buildozer/android/platform/android-sdk/cmdline-tools/latest/bin/sdkmanager --licenses || true
          # Build
          buildozer android debug 2>&1 | tee build.log
          # Exit with buildozer exit code (not tee's)
          exit ${PIPESTATUS[0]}

      # ── 9. Bundle GGUF model into APK (post-process, bypass Gradle) ── #
      - name: Bundle GGUF model into APK
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e

          # --- 9a. Get llama-server ARM64 binary ---
          echo "=== Getting llama-server ARM64 binary ==="

          # Method 1: Download pre-built binary using authenticated gh CLI
          LATEST_TAG=$(gh release list --repo ggml-org/llama.cpp --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null)
          echo "Latest llama.cpp tag: $LATEST_TAG"
          mkdir -p llama_dl
          gh release download "$LATEST_TAG" --repo ggml-org/llama.cpp --pattern "*android*arm64*" --dir llama_dl 2>&1 || echo "gh download failed"
          ls -la llama_dl/ 2>/dev/null || echo "llama_dl empty"

          # Extract llama-server from downloaded zip
          python3 - <<'BINEOF'
          import zipfile, os, shutil, glob

          found = False
          for zpath in glob.glob("llama_dl/*.zip"):
              print(f"Extracting {zpath}...")
              with zipfile.ZipFile(zpath) as zf:
                  zf.extractall("llama_dl_extracted")
              for root, dirs, files in os.walk("llama_dl_extracted"):
                  for f in sorted(files):
                      if "llama-server" in f.lower() and not f.endswith(".so"):
                          src = os.path.join(root, f)
                          sz = os.path.getsize(src)
                          if sz > 100_000:
                              shutil.copy2(src, "llama-server-arm64")
                              os.chmod("llama-server-arm64", 0o755)
                              print(f"Binary ready: {f} ({sz//1024} KB)")
                              found = True
                              break
                  if found:
                      break
          if not found:
              print("Pre-built binary not found in download")
          BINEOF

          # Method 2: Compile from source (fallback if download failed)
          if [ ! -f "llama-server-arm64" ] || [ ! -s "llama-server-arm64" ]; then
            echo "Falling back to source compilation..."
            NDK_TOOLCHAIN=$(find $HOME/.buildozer/android/platform -name "android.toolchain.cmake" 2>/dev/null | head -1)
            echo "NDK toolchain: $NDK_TOOLCHAIN"

            if [ -n "$NDK_TOOLCHAIN" ] && [ -d "llama_cpp_src" ]; then
              # Find the NDK clang compiler explicitly
              NDK_ROOT=$(dirname $(dirname $(dirname "$NDK_TOOLCHAIN")))
              CLANG=$(find "$NDK_ROOT" -name "aarch64-linux-android*-clang" -type f 2>/dev/null | head -1)
              echo "NDK root: $NDK_ROOT"
              echo "Clang: $CLANG"

              cmake -S llama_cpp_src -B llama_cpp_src/build_android \
                -DCMAKE_TOOLCHAIN_FILE="$NDK_TOOLCHAIN" \
                -DANDROID_ABI=arm64-v8a \
                -DANDROID_PLATFORM=android-26 \
                -DCMAKE_BUILD_TYPE=Release \
                -DLLAMA_BUILD_SERVER=ON \
                -DGGML_NATIVE=OFF \
                -DBUILD_SHARED_LIBS=OFF \
                -DLLAMA_CURL=OFF 2>&1

              cmake --build llama_cpp_src/build_android --target llama-server -j$(nproc) 2>&1

              BIN=$(find llama_cpp_src/build_android -name "llama-server" -not -name "*.so" -type f 2>/dev/null | head -1)
              if [ -n "$BIN" ]; then
                cp "$BIN" llama-server-arm64
                chmod +x llama-server-arm64
                echo "Compiled binary: $(du -sh llama-server-arm64)"
              else
                echo "ERROR: cmake compilation produced no binary"
                find llama_cpp_src/build_android -type f 2>/dev/null | head -30
              fi
            else
              echo "ERROR: NDK toolchain not found"
            fi
          fi

          if [ -f "llama-server-arm64" ] && [ -s "llama-server-arm64" ]; then
            echo "llama-server-arm64 READY: $(du -sh llama-server-arm64)"
          else
            echo "CRITICAL: llama-server-arm64 NOT AVAILABLE — LLM backend will be broken"
          fi

          # --- 9b. Download the GGUF model ---
          echo "=== Downloading GGUF model ==="
          pip install huggingface-hub --quiet
          python3 - <<'PYEOF'
          import os, sys
          from huggingface_hub import hf_hub_download
          path = hf_hub_download(
              repo_id  = "mradermacher/Gemma-3-1B-it-GLM-4.7-Flash-Heretic-Uncensored-Thinking-i1-GGUF",
              filename = "Gemma-3-1B-it-GLM-4.7-Flash-Heretic-Uncensored-Thinking.i1-Q4_K_M.gguf",
              local_dir= "model_tmp",
              local_dir_use_symlinks=False,
          )
          size_mb = os.path.getsize(path) // 1_048_576
          print(f"Downloaded: {path}  ({size_mb} MB)")
          PYEOF

          # --- 9b. Patch the APK: strip old signature, add model as ZIP_STORED ---
          python3 - <<'PYEOF'
          import zipfile, glob, os

          apk_path   = glob.glob("bin/*.apk")[0]
          model_path = glob.glob("model_tmp/*.gguf")[0]
          bin_src    = "llama-server-arm64"

          print(f"Source APK:  {apk_path}  ({os.path.getsize(apk_path)//1_048_576} MB)")
          print(f"Model:       {model_path}  ({os.path.getsize(model_path)//1_048_576} MB)")
          has_bin = os.path.exists(bin_src)
          if has_bin:
              print(f"Binary:      {bin_src}  ({os.path.getsize(bin_src)//1024} KB)")
          else:
              print("WARNING: llama-server-arm64 NOT FOUND — LLM backend will be unavailable!")

          # ── Pass 1: copy existing entries + add model (STORED, no compression) ──
          tmp_path = apk_path + ".patching.tmp"
          CHUNK = 4 * 1024 * 1024

          with zipfile.ZipFile(apk_path, "r") as src, \
               zipfile.ZipFile(tmp_path, "w", compression=zipfile.ZIP_DEFLATED, allowZip64=True) as dst:

              for item in src.infolist():
                  if item.filename.startswith("META-INF/"):
                      continue
                  dst.writestr(item, src.read(item.filename))

              print("Adding model (ZIP_STORED)…")
              info = zipfile.ZipInfo("assets/models/model.gguf")
              info.compress_type = zipfile.ZIP_STORED
              written = 0
              with open(model_path, "rb") as mf, dst.open(info, "w") as zout:
                  while True:
                      chunk = mf.read(CHUNK)
                      if not chunk:
                          break
                      zout.write(chunk)
                      written += len(chunk)
                      print(f"  {written // 1_048_576} MB…", flush=True)

              # Add binary inside the same pass (avoids a second full APK re-pack)
              if has_bin:
                  print("Adding llama-server-arm64 (ZIP_STORED)…")
                  bin_info = zipfile.ZipInfo("llama-server-arm64")
                  bin_info.compress_type = zipfile.ZIP_STORED
                  with open(bin_src, "rb") as bf, dst.open(bin_info, "w") as zout:
                      while True:
                          chunk = bf.read(CHUNK)
                          if not chunk:
                              break
                          zout.write(chunk)

          os.replace(tmp_path, apk_path)
          print(f"Done.  Final APK size: {os.path.getsize(apk_path)//1_048_576} MB")
          PYEOF

          # --- 9c. Create a debug signing keystore ---
          mkdir -p ~/.android
          keytool -genkey -v \
            -keystore ~/.android/debug.keystore \
            -alias androiddebugkey \
            -keyalg RSA -keysize 2048 -validity 10000 \
            -storepass android -keypass android \
            -dname "CN=Android Debug,O=Android,C=US" \
            -noprompt 2>/dev/null || true

          # --- 9d. Re-sign with apksigner from Android build-tools ---
          APKSIGNER=$(find $HOME/.buildozer/android/platform/android-sdk/build-tools \
            -name "apksigner" -type f 2>/dev/null | sort -V | tail -1)
          echo "apksigner: $APKSIGNER"

          APK=$(find bin -name "*.apk" | head -1)
          "$APKSIGNER" sign \
            --ks ~/.android/debug.keystore \
            --ks-pass pass:android \
            --key-pass pass:android \
            "$APK"

          echo "=== Final bundled APK ==="
          ls -lh bin/*.apk

      # ── 10. Upload APK as artifact ─────────────────────────────────── #
      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: OfflineRAG-debug-apk
          path: bin/*.apk
          retention-days: 30
          if-no-files-found: error

      # ── 10. Upload build log if anything fails ─────────────── #
      - name: Upload build log (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-log
          path: build.log
          retention-days: 7

