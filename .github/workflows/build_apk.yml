name: Build Android APK

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-apk:
    runs-on: ubuntu-22.04
    timeout-minutes: 120

    steps:
      # ── 1. Checkout ───────────────────────────────────────── #
      - name: Checkout repository
        uses: actions/checkout@v4

      # ── 2. Set up Python ─────────────────────────────────── #
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # ── 3. Set up Java 17 (required by p4a's AGP 8.x) ────────────── #
      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      # ── 4. System packages ────────────────────────────────── #
      - name: Install system packages
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            git zip unzip ninja-build \
            autoconf libtool pkg-config \
            zlib1g-dev libncurses5-dev libncursesw5-dev \
            libtinfo5 cmake libffi-dev libssl-dev \
            wget lld clang

      # ── 5. Install Buildozer + python-for-android ────────── #
      - name: Install Buildozer
        run: |
          pip install --upgrade pip setuptools wheel cython
          pip install buildozer python-for-android

      # ── 6. Cache Android SDK/NDK and p4a builds ──────────── #
      - name: Cache Buildozer global dir
        uses: actions/cache@v4
        with:
          path: ~/.buildozer
          key: buildozer-${{ runner.os }}-${{ github.repository_id }}-${{ hashFiles('buildozer.spec') }}
          restore-keys: buildozer-${{ runner.os }}-${{ github.repository_id }}-

      - name: Cache .buildozer project dir
        uses: actions/cache@v4
        with:
          path: .buildozer
          key: buildozer-project-${{ runner.os }}-${{ github.repository_id }}-${{ hashFiles('buildozer.spec','requirements.txt') }}
          restore-keys: buildozer-project-${{ runner.os }}-${{ github.repository_id }}-

      # ── 7. Clone llama.cpp source (compiled after NDK is ready) ─────── #
      - name: Clone llama.cpp source
        run: |
          # Clone to /tmp so it is NOT inside the workspace (source.dir=.)
          # Keeping it in the workspace causes buildozer to scan thousands of
          # llama.cpp .py files, which can corrupt the app source copy and
          # results in "No main.py found" during p4a APK packaging.
          git clone --depth 1 https://github.com/ggml-org/llama.cpp.git /tmp/llama_cpp_src
          echo "llama.cpp cloned: $(ls /tmp/llama_cpp_src)"

      # ── 8. Build APK ─────────────────────────────────────────────── #
      - name: Build Android debug APK
        env:
          # Give the Gradle daemon enough heap for asset processing
          GRADLE_OPTS: "-Xmx4g -XX:MaxMetaspaceSize=512m"
        run: |
          # Confirm Java version
          java -version
          # Unset PYTHONHOME/PYTHONPATH so host Python finds its own stdlib
          # (p4a cross-compilation can corrupt these, causing 'No module named encodings')
          unset PYTHONHOME PYTHONPATH
          # Delete stale hostpython3 build — it embeds absolute repo paths that
          # break when cache is restored from a different repo clone (e.g. offline-rag-android -> o-rag)
          rm -rf .buildozer/android/platform/build-arm64-v8a/build/other_builds/hostpython3 2>/dev/null || true
          rm -rf ~/.buildozer/android/platform/build-arm64-v8a/build/other_builds/hostpython3 2>/dev/null || true
          # Delete ALL stale dists (handles dist_name changes, e.g. offlinerag -> orag)
          rm -rf .buildozer/android/platform/build-arm64-v8a/dists/
          rm -rf ~/.buildozer/android/platform/build-arm64-v8a/dists/ 2>/dev/null || true
          # Always wipe the app source dir so buildozer re-copies fresh files
          # (stale cache causes "No main.py found" failure in p4a SDL2 bootstrap)
          rm -rf .buildozer/android/app 2>/dev/null || true
          # Pin Cython to a version compatible with pyjnius (kivy dep)
          pip install "cython==0.29.37" --quiet
          # Ensure ~/.android exists (needed by keytool / sdkmanager)
          mkdir -p ~/.android && touch ~/.android/repositories.cfg
          # Pipe yes to answer any SDK license prompts interactively
          # PIPESTATUS: 0=yes, 1=buildozer, 2=tee
          yes 2>/dev/null | buildozer android debug 2>&1 | tee build.log
          exit ${PIPESTATUS[1]}

      # ── 9. Compile llama-server + bundle model + patch APK ── #
      - name: Bundle server binary and GGUF model into APK
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e

          # ── 9a. Compile llama-server for Android ARM64 ───────────────
          echo "=== Step 9a: Compiling llama-server for Android ARM64 ==="

          NDK_HOME=$(find $HOME/.buildozer/android/platform -maxdepth 1 \
            -name "android-ndk-*" -type d | head -1)
          TOOLCHAIN="$NDK_HOME/build/cmake/android.toolchain.cmake"

          echo "NDK: $NDK_HOME"
          echo "Toolchain: $TOOLCHAIN"

          if [ ! -f "$TOOLCHAIN" ]; then
            echo "FATAL: Android NDK toolchain not found!"
            find $HOME/.buildozer/android/platform -name "android.toolchain.cmake" 2>/dev/null
            exit 1
          fi

          cmake -S /tmp/llama_cpp_src -B llama_build \
            -G Ninja \
            -DCMAKE_TOOLCHAIN_FILE="$TOOLCHAIN" \
            -DANDROID_ABI=arm64-v8a \
            -DANDROID_PLATFORM=android-28 \
            -DCMAKE_BUILD_TYPE=MinSizeRel \
            -DGGML_NATIVE=OFF \
            -DGGML_OPENMP=OFF \
            -DBUILD_SHARED_LIBS=OFF \
            -DLLAMA_CURL=OFF \
            -DLLAMA_BUILD_TESTS=OFF \
            -DLLAMA_BUILD_EXAMPLES=ON \
            -DLLAMA_SERVER_VERBOSE=OFF
          echo "cmake configure done (exit $?)"

          cmake --build llama_build --target llama-server -j$(nproc)
          echo "cmake build done (exit $?)"

          BIN=$(find llama_build -name "llama-server" -type f 2>/dev/null | head -1)
          echo "Binary found at: $BIN"
          if [ -z "$BIN" ]; then
            echo "ERROR: llama-server not found. All built files:"
            find llama_build -type f 2>/dev/null | head -40
            exit 1
          fi
          cp "$BIN" llama-server-arm64
          chmod 755 llama-server-arm64
          # Strip debug symbols to shrink the binary (~15-25 MB saved)
          STRIP="$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip"
          if [ -f "$STRIP" ]; then
            "$STRIP" --strip-unneeded llama-server-arm64
            echo "Stripped binary size: $(du -sh llama-server-arm64)"
          else
            echo "WARNING: llvm-strip not found, skipping strip."
          fi
          echo "SUCCESS: $(du -sh llama-server-arm64)"

          # ── 9b. Download GGUF models ──────────────────────────────────
          # Qwen Q3_K_M: ~780 MB vs Q4_K_M ~1065 MB — saves ~285 MB in the APK.
          # Nomic (~80 MB) is NOT bundled — it downloads on first PDF upload.
          echo "=== Step 9b: Downloading Qwen 2.5 1.5B Instruct Q3_K_M GGUF model ==="
          pip install huggingface-hub --quiet
          python3 - <<'PYEOF'
          import os
          from huggingface_hub import hf_hub_download

          # Qwen generation model — Q3_K_M (~780 MB, saves ~285 MB vs Q4_K_M)
          path = hf_hub_download(
              repo_id="Qwen/Qwen2.5-1.5B-Instruct-GGUF",
              filename="qwen2.5-1.5b-instruct-q3_k_m.gguf",
              local_dir="model_tmp",
              local_dir_use_symlinks=False,
          )
          print(f"Qwen model: {path} ({os.path.getsize(path)//1_048_576} MB)")
          PYEOF

          # ── 9c. Patch APK — inject model + binary in one pass ────────
          echo "=== Step 9c: Patching APK ==="
          python3 - <<'PYEOF'
          import zipfile, glob, os

          apk        = glob.glob("bin/*.apk")[0]
          model      = glob.glob("model_tmp/qwen*.gguf")[0]
          srv        = "llama-server-arm64"
          tmp   = apk + ".tmp"
          CHUNK = 4 * 1024 * 1024

          print(f"APK:    {apk}  ({os.path.getsize(apk)//1_048_576} MB)")
          print(f"Model:  {model}  ({os.path.getsize(model)//1_048_576} MB)")
          print(f"Binary: {srv}  ({os.path.getsize(srv)//1024} KB)")
          # NOTE: Nomic (~80 MB) is intentionally NOT bundled.
          # The app downloads it automatically on first PDF upload.

          with zipfile.ZipFile(apk, "r") as src, \
               zipfile.ZipFile(tmp, "w", compression=zipfile.ZIP_DEFLATED, allowZip64=True) as dst:

              for item in src.infolist():
                  if item.filename.startswith("META-INF/"):
                      continue
                  dst.writestr(item, src.read(item.filename))

              print("Adding Qwen model (ZIP_STORED, uncompressed)...")
              mi = zipfile.ZipInfo("assets/models/model.gguf")
              mi.compress_type = zipfile.ZIP_STORED
              written = 0
              with open(model, "rb") as mf, dst.open(mi, "w") as zo:
                  while chunk := mf.read(CHUNK):
                      zo.write(chunk)
                      written += len(chunk)
                      if written % (100*1024*1024) == 0:
                          print(f"  {written//1_048_576} MB...", flush=True)

              # Bundle as a native library so Android extracts it at install
              # time to nativeLibraryDir — the ONLY location SELinux allows
              # execve() for app processes on Android 10+.
              print("Adding lib/arm64-v8a/libllama_server.so (ZIP_STORED)...")
              bi = zipfile.ZipInfo("lib/arm64-v8a/libllama_server.so")
              bi.compress_type = zipfile.ZIP_STORED
              bi.external_attr = 0o755 << 16
              with open(srv, "rb") as bf, dst.open(bi, "w") as zo:
                  while chunk := bf.read(CHUNK):
                      zo.write(chunk)

          os.replace(tmp, apk)
          final_size = os.path.getsize(apk)
          print(f"Done. Final APK: {final_size//1_048_576} MB")

          # Verify entries are present
          with zipfile.ZipFile(apk, 'r') as vf:
              names = vf.namelist()
              for check in ["lib/arm64-v8a/libllama_server.so",
                             "assets/models/model.gguf"]:
                  found = check in names
                  sz = vf.getinfo(check).file_size // 1024 if found else 0
                  print(f"  {'OK' if found else 'MISSING'}: {check} ({sz} KB)")
          PYEOF

          # ── 9d. Sign APK ──────────────────────────────────────────────
          echo "=== Step 9d: Signing APK ==="
          mkdir -p ~/.android
          keytool -genkey -v \
            -keystore ~/.android/debug.keystore \
            -alias androiddebugkey \
            -keyalg RSA -keysize 2048 -validity 10000 \
            -storepass android -keypass android \
            -dname "CN=Android Debug,O=Android,C=US" \
            -noprompt 2>/dev/null || true

          APKSIGNER=$(find $HOME/.buildozer/android/platform/android-sdk/build-tools \
            -name "apksigner" -type f 2>/dev/null | sort -V | tail -1)
          APK=$(find bin -name "*.apk" | head -1)
          "$APKSIGNER" sign \
            --ks ~/.android/debug.keystore \
            --ks-pass pass:android --key-pass pass:android \
            "$APK"

          echo "=== FINAL APK ==="
          ls -lh bin/*.apk

      # ── 10. Upload APK as artifact ─────────────────────────────────── #
      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: O-RAG-debug-apk
          path: bin/*.apk
          retention-days: 30
          if-no-files-found: error

      # ── 11. Upload build log if anything fails ─────────────── #
      - name: Upload build log (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-log
          path: build.log
          retention-days: 7
